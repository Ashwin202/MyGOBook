<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./css/main.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

</head>
 <body>
    <h1>Pointers in Go</h1>
    <hr>
    <h2>Introduction</h2>
    <p>Pointers in Go are variables that store the memory address of another variable. They allow direct and efficient manipulation of memory, which is essential for certain types of programming tasks.</p>

    <h2>Variables and Memory</h2>
    <p>In Go, variables hold values that are stored in memory. Pointers provide a way to access and modify these values indirectly by referencing their memory addresses.</p>

    <h2>Basic Pointer Example</h2>

    <h3>Declaration and Initialization</h3>
    <p>To declare a pointer, you use the asterisk (*) before the type name of the variable it points to. You can initialize a pointer using the address-of operator (&).</p>

    <pre><code>package pointers

import "fmt"

func BasicPointers() {
    // Declare a variable
    testVar := 10

    // Declare a pointer variable
    var testPointer *int

    // Assign the address of testVar to testPointer
    testPointer = &testVar

    fmt.Println("Value of testVar:", testVar)
    fmt.Println("Address of testVar:", testPointer)
    fmt.Println("Value pointed to by testPointer:", *testPointer)

    // Modify the value of testVar indirectly using the pointer
    *testPointer = 20
    fmt.Println("Modified value of testVar:", testVar)
}
</code></pre>

    <h3>Explanation</h3>
    <ul>
        <li><strong>Declaration and Initialization:</strong> Shows how to declare a pointer variable, assign it the address of another variable, and access the value at that address using the dereference operator (*)</li>
        <li><strong>Modification via Pointer:</strong> Demonstrates how to modify the value of a variable indirectly through its pointer.</li>
    </ul>

    <h2>Advanced Usage</h2>

    <h3>Pointers to Structs</h3>
    <p>Pointers are particularly useful with structs in Go, allowing efficient access and modification of struct fields.</p>

    <pre><code>package pointers

import "fmt"

type Person struct {
    Name string
    Age  int
}

func PointersToStructs() {
    // Declare a struct variable
    var p1 Person
    p1.Name = "Alice"
    p1.Age = 30

    // Declare a pointer to the struct
    var pp1 *Person
    pp1 = &p1

    // Access struct fields via the pointer
    fmt.Println("Name:", pp1.Name)
    fmt.Println("Age:", pp1.Age)

    // Modify struct fields via the pointer
    pp1.Age = 31
    fmt.Println("Modified Age:", p1.Age)
}
</code></pre>

    <h3>Pointers with Slices and Maps</h3>
    <p>Slices and maps in Go are inherently passed by reference, which means they behave like pointers to underlying data structures.</p>

    <pre><code>package pointers

import "fmt"

func SlicesAndMaps() {
    // Slice example
    slice := []int{1, 2, 3}
    fmt.Println("Slice before modification:", slice)
    modifySlice(slice)
    fmt.Println("Slice after modification:", slice)

    // Map example
    ages := map[string]int{"Alice": 30, "Bob": 25}
    fmt.Println("Ages before modification:", ages)
    modifyMap(ages)
    fmt.Println("Ages after modification:", ages)
}

func modifySlice(s []int) {
    s[0] = 100
}

func modifyMap(m map[string]int) {
    m["Alice"] = 31
}
</code></pre>

<h2>Where to Use Pointers</h2>

<p>Pointers are particularly useful in the following scenarios:</p>

<ul>
    <li><strong>Efficiently Passing Large Data:</strong> When passing large structs or arrays between functions, using pointers avoids unnecessary copying of data, thus improving performance.</li>
    <li><strong>Modifying Function Parameters:</strong> If a function needs to modify the original value of a parameter (such as updating a counter or setting an error condition), it can use a pointer to directly access and change the variable.</li>
    <li><strong>Sharing Data Between Goroutines:</strong> In concurrent programming with goroutines, pointers enable multiple goroutines to access and modify shared data structures safely.</li>
    <li><strong>Reducing Memory Footprint:</strong> Instead of duplicating large data structures, pointers allow multiple parts of a program to reference and manipulate the same data in memory.</li>
    <li><strong>Manipulating Data Structures:</strong> Pointers facilitate efficient manipulation of linked data structures like linked lists, trees, and graphs where nodes need to reference each other.</li>
</ul>

<p>While pointers offer these advantages, they also require careful handling to avoid common pitfalls like null pointer dereferencing or unintended data sharing.</p>


    <h3>Conclusion</h3>
    <p>Pointers in Go provide powerful capabilities for managing memory efficiently and enabling direct access to variables and data structures. Understanding pointers is crucial for developing performant and effective Go programs.</p>

 </body>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="./js/main.js"></script>

</html>